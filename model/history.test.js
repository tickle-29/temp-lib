"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const store_1=require("./store");jest.useFakeTimers(),jest.mock("../utils/validate-key",(()=>({__esModule:!0,validateKey:()=>{}}))),test("no history by default",(()=>{const e=(0,store_1.createStore)();expect(e.history.canUndo).toBe(!1),expect(e.history.canRedo).toBe(!1)})),test("new history item when we add svg element",(async()=>{const e=(0,store_1.createStore)();expect(e.history.canUndo).toBe(!1);const t=e.addPage();jest.runAllTimers(),t.addElement({type:"svg",src:""}),jest.runAllTimers(),expect(e.history.history.length).toBe(2)})),test("check simple undo",(async()=>{const e=(0,store_1.createStore)();expect(e.history.history.length).toBe(0),expect(e.history.canUndo).toBe(!1),e.addPage(),jest.runAllTimers();const t=e.toJSON();expect(e.history.history.length).toBe(1),e.addPage(),jest.runAllTimers(),e.history.undo(),expect(e.toJSON()).toEqual(t)})),test("ignoring should not create new history item",(async()=>{const e=(0,store_1.createStore)(),t=e.addPage();expect(e.history.canUndo).toBe(!1),jest.runAllTimers(),expect(e.history.history.length).toBe(1),await e.history.ignore((()=>{t.set({bleed:2})})),jest.runAllTimers(),expect(e.history.history.length).toBe(1)})),test("after loading of JSON, ignored transactions should not create new history items",(async()=>{const e=(0,store_1.createStore)(),t=e.addPage();jest.runAllTimers(),expect(e.history.history.length).toBe(1),e.addPage(),e.loadJSON({width:100,height:100,pages:[]}),await e.history.ignore((()=>{t.set({bleed:2})})),jest.runAllTimers(),expect(e.history.history.length).toBe(1)})),test("ignoring action should save previous pending changes",(async()=>{const e=(0,store_1.createStore)(),t=e.addPage();jest.runAllTimers(),expect(e.history.history.length).toBe(1),t.set({bleed:1}),await e.history.ignore((()=>{t.set({bleed:2})})),expect(e.history.history.length).toBe(2),jest.runAllTimers(),expect(e.history.history.length).toBe(2),await e.history.ignore((()=>{t.set({bleed:3})})),jest.runAllTimers(),expect(e.history.history.length).toBe(2)})),test("ignoring action should save previous pending changes",(async()=>{const e=(0,store_1.createStore)(),t=e.addPage();jest.runAllTimers(),expect(e.history.history.length).toBe(1),t.set({bleed:1}),e.history.ignore((()=>{t.set({bleed:2})})),expect(e.history.history.length).toBe(2),jest.runAllTimers(),expect(e.history.history.length).toBe(2),e.history.ignore((()=>{t.set({bleed:3})})),jest.runAllTimers(),expect(e.history.history.length).toBe(2)})),test("ignored changed should not create new history commit after possible state change",(async()=>{const e=(0,store_1.createStore)(),t=e.addPage();jest.runAllTimers(),expect(e.history.history.length).toBe(1),await e.history.transaction((()=>{t.addElement({type:"text",text:"hello"})})),jest.runAllTimers(),expect(e.history.history.length).toBe(2),await e.history.ignore((()=>{t.set({bleed:20})})),t.set({_exporting:!0}),jest.runAllTimers(),expect(e.history.history.length).toBe(2)})),test("ignore during transaction",(async()=>{const e=(0,store_1.createStore)(),t=e.addPage();jest.runAllTimers();const s=e.toJSON();await e.history.transaction((async()=>{t.addElement({type:"text",text:"hello"});await e.history.ignore((()=>{t.set({bleed:30})}))})),jest.runAllTimers(),expect(e.history.history.length).toBe(2),e.history.undo(),expect(e.toJSON()).toEqual(s)})),test("ignore several times should handle all correctly",(async()=>{const e=(0,store_1.createStore)(),t=e.addPage();jest.runAllTimers();const s=e.toJSON();await e.history.transaction((async()=>{t.addElement({type:"text",text:"hello"})})),await e.history.ignore((()=>{t.set({bleed:30})})),await e.history.ignore((()=>{t.set({bleed:40})})),jest.runAllTimers(),expect(e.history.history.length).toBe(2),e.history.undo(),expect(e.toJSON()).toEqual(s),jest.runAllTimers()}));